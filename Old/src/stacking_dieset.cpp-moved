/* dwarfpp: C++ binding for a useful subset of libdwarf, plus extra goodies.
 * 
 * stacking_dieset.cpp: combining many diesets in an overlaid fashion.
 *
 * Copyright (c) 2010, Stephen Kell.
 */

#include "stacking_dieset.hpp"

/* PROBLEM: children, iterators etc.
 * Now a DIE can be participating in more than one dieset at a time:
 * firstly its immediate container, and also zero or more stacking diesets. 
 * What should the behaviour be when getting iterators, querying children,
 * etc.? In what circumstances should we get the immediate dieset, and
 * when should we get a containing dieset?
 *
 * I think the p_ds field in struct position may save us. It tells us
 * which dieset a given iterator is from.
 * BUT
 * getting children from a DIE is tricky, as is getting iterator_here:
 * the DIE is agnostic about which dieset is the right one. 
 * We could fix this with an extra argument to iterator_here, children_begin
 * and so on.
 * Alternatively we could wrap every single DIE that is accessed through
 * the stacking_dieset, s.t. it issues iterators from the containing dieset.
 * Is that straightforward? 
 * -- Yes, IF we add the extra-argument versions?
 * This is really an example of content versus context.
 * Previously, the appropriate dieset was content (fixed association with the DIE)
 * Now it must be recovered from context (argument)
 * ... because we have a more complex data model.
 * Note that if we're getting one iterator through another
 * e.g (*i_die)->children_begin(...)
 * then we have repetition:
 * (*i_die)->children_begin(i_die.base().p_ds)
 * -- we'd much rather not have to write this. 
 * Multiple dispatch would solve this, effectively equivalently to context-sensitivity...
 * ... i.e. *i_die returns a special object which knows which iterator created it
 * and dispatches children_begin() with its own 
 * 
 * 
 * We really want double dispatch here: any iterator-returning function
 *                                  and any child-offset/reference-returning function
 * is dispatched on both the DIE and the dieset. OR, hmm, just the dieset?
 *
 * Another PROBLEM: DIEs have a get_ds() call. Okay -- this is fixable. 
 *
 * ALTERNATIVE: just reimplement the whole thing, 
 * returning shared_ptrs to encap::dies at each stage.
 * This works because we can encapsulate any DIE and then let the lib::die lapse.
 * They can be mostly like existing encap::dies, just 
 * This means creating new iterator policy classes.
 * Can we avoid creating a new implementation of basic_die?
 * Hmm, YES if all access to the ds is through get_ds()
 *
 * Gut feeling is that this is a better trade than adding an argument
 * to accessor methods, because doesn't disrupt the user experience.
 */

/* virtual */ iterator 
stacking_dieset::find(Dwarf_Off off)
{
	for (auto i_ds = ds_vec.begin(); i_ds != ds_vec.end(); i_ds++)
	{
		if (i_ds->find(off) != i_ds.end())
		{
			return iterator_factory()(i_ds->find(off));
			// the iterator that this returns
			// has a special dereference operator
			// which wraps the returned die's
			// iterator- and children- and parent- returning functions
			// Easiest way to do this is always to refer to the
			// dieset when doing any of these things.
			// Perhaps we can make all those methods nonvirtual 
			// simply calling into the dieset, which can then
			// do the implementation-specific thing on them.
			// This assumes that we don't ever want to subclass
			// DIE types without subclassing the dieset --
			// probably sensible. 
			// How does this overlap with what policy objects do?
			// Can we localise the knowledge there? i.e. express
			// next_child and so on in terms of iterator increments
			// OR do we want to do this the other way?
			// It's not clear how some ops, like get_parent(), would work here.
			// So let's put an up(), down(), left(), right()-type interface
			// in the dieset. These take iterators or positions and return the same.
			// -- iterators, or sth with path_from_root,
			//    is necessary to make up() operations efficient
			// Can I use information hiding to catch this?
		}
	}
	return end();
}

/* virtual */ iterator 
stacking_dieset::begin()
{
	/* This should return an iterator to the first element in
	 * depthfirst order. We need an ordering on */
}

/* virtual */ iterator 
stacking_dieset::end()
{
	return /* iterator with p_ds null, offset == numeric_limits<Dwarf_Off>::max() 
	 --- check that this will equality-test okay! */
}

/* virtual */ std::deque< position > 
stacking_dieset::path_from_root(Dwarf_Off off)
{
	/* Tricky one: we have to ensure that the path we get 
	 * is valid in the overall stacking dieset -- i.e. that 
	 * none of the offsets are.
	 *
	 * Then rewrite p_ds in each position
	 * s.t. it references *this* ds. */
}

/* virtual */ boost::shared_ptr<spec::basic_die> 
stacking_dieset::operator[](Dwarf_Off off) const
{
	
}

/* virtual */ boost::shared_ptr<spec::file_toplevel_die> 
stacking_dieset::toplevel() /* NOT const */
{
	
}

/* virtual */ const spec::abstract_def& 
stacking_dieset::get_spec() const
{
	return ds_vec.at(0)->get_spec();
}
